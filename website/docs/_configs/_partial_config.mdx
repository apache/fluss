{/* This file is auto-generated. Do not edit directly. */}

## Acl Configurations

### `acl.notification.expiration-time` {#acl-notification-expiration-time}

* **Default**: `PT15M`
* **Type**: Duration
* **Scope**: Server

The duration for which ACL notifications are valid before they expire. This configuration determines the time window during which an ACL notification is considered active. After this duration, the notification will no longer be valid and will be discarded. The default value is 15 minutes. This setting is important to ensure that ACL changes are propagated in a timely manner and do not remain active longer than necessary.

---

## Advertised Configurations

### `advertised.listeners` {#advertised-listeners}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The externally advertised address and port for client connections. Required in distributed environments when the bind address is not publicly reachable. Format matches `bind.listeners` (listener_name://host:port). Defaults to the value of `bind.listeners` if not explicitly configured.

---

## Allow Configurations

### `allow.create.kv.tables` {#allow-create-kv-tables}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Server

Whether to allow creation of kv tables (primary key tables). When set to false, attempts to create kv tables (tables with primary key) will be rejected. The default value is true.

---

### `allow.create.log.tables` {#allow-create-log-tables}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Server

Whether to allow creation of log tables. When set to false, attempts to create log tables (tables without primary key) will be rejected. The default value is true.

---

## Authorizer Configurations

### `authorizer.enabled` {#authorizer-enabled}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

Specifies whether to enable the authorization feature. If enabled, access control is enforced based on the authorization rules defined in the configuration. If disabled, all operations and resources are accessible to all users.

---

### `authorizer.type` {#authorizer-type}

* **Default**: `default`
* **Type**: String
* **Scope**: Server

Specifies the type of authorizer to be used for access control. This value corresponds to the identifier of the authorization plugin. The default value is `default`, which indicates the built-in authorizer implementation. Custom authorizers can be implemented by providing a matching plugin identifier.

---

## Auto-partition Configurations

### `auto-partition.check.interval` {#auto-partition-check-interval}

* **Default**: `PT10M`
* **Type**: Duration
* **Scope**: Server

The interval of auto partition check. The default value is 10 minutes.

---

## Bind Configurations

### `bind.listeners` {#bind-listeners}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The network address and port to which the server binds for accepting connections. This defines the interface and port where the server will listen for incoming requests. The format is `listener_name://host:port`, and multiple addresses can be specified, separated by commas. Use `0.0.0.0` for the `host` to bind to all available interfaces which is dangerous on production and not suggested for production usage. The `listener_name` serves as an identifier for the address in the configuration. For example, `internal.listener.name` specifies the address used for internal server communication. If multiple addresses are configured, ensure that the `listener_name` values are unique.

---

## Bootstrap Configurations

### `bootstrap.servers` {#bootstrap-servers}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

A list of host/port pairs to use for establishing the initial connection to the Fluss cluster. The list should be in the form host1:port1,host2:port2,.... Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down) 

---

## Client Configurations

### `client.connect-timeout` {#client-connect-timeout}

* **Default**: `PT2M`
* **Type**: Duration
* **Scope**: Client

The Netty client connect timeout.

---

### `client.filesystem.security.token.renewal.backoff` {#client-filesystem-security-token-renewal-backoff}

* **Default**: `PT1H`
* **Type**: Duration
* **Scope**: Client

The time period how long to wait before retrying to obtain new security tokens for filesystem after a failure.

---

### `client.filesystem.security.token.renewal.time-ratio` {#client-filesystem-security-token-renewal-time-ratio}

* **Default**: `0.75`
* **Type**: Double
* **Scope**: Client

Ratio of the token's expiration time when new credentials for access filesystem should be re-obtained.

---

### `client.id` {#client-id}

* **Default**: ``
* **Type**: String
* **Scope**: Client

An id string to pass to the server when making requests. The purpose of this is to be able to track the source of requests beyond just ip/port by allowing a logical application name to be included in server-side request logging.

---

### `client.lookup.batch-timeout` {#client-lookup-batch-timeout}

* **Default**: `PT0.1S`
* **Type**: Duration
* **Scope**: Client

The maximum time to wait for the lookup batch to full, if this timeout is reached, the lookup batch will be closed to send.

---

### `client.lookup.max-batch-size` {#client-lookup-max-batch-size}

* **Default**: `128`
* **Type**: Int
* **Scope**: Client

The maximum batch size of merging lookup operations to one lookup request.

---

### `client.lookup.max-inflight-requests` {#client-lookup-max-inflight-requests}

* **Default**: `128`
* **Type**: Int
* **Scope**: Client

The maximum number of unacknowledged lookup requests for lookup operations.

---

### `client.lookup.max-retries` {#client-lookup-max-retries}

* **Default**: `2147483647`
* **Type**: Int
* **Scope**: Client

Setting a value greater than zero will cause the client to resend any lookup request that fails with a potentially transient error.

---

### `client.lookup.queue-size` {#client-lookup-queue-size}

* **Default**: `25600`
* **Type**: Int
* **Scope**: Client

The maximum number of pending lookup operations.

---

### `client.metrics.enabled` {#client-metrics-enabled}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Client

Enable metrics for client. When metrics is enabled, the client will collect metrics and report by the JMX metrics reporter.

---

### `client.remote-file.download-thread-num` {#client-remote-file-download-thread-num}

* **Default**: `3`
* **Type**: Int
* **Scope**: Client

The number of threads the client uses to download remote files.

---

### `client.request-timeout` {#client-request-timeout}

* **Default**: `PT30S`
* **Type**: Duration
* **Scope**: Client

The timeout for a request to complete. If user set the write ack to -1, this timeout is the max time that delayed write try to complete. The default setting is 30 seconds.

---

### `client.scanner.io.tmpdir` {#client-scanner-io-tmpdir}

* **Default**: `/tmp/fluss`
* **Type**: String
* **Scope**: Client

Local directory that is used by client for storing the data files (like kv snapshot, log segment files) to read temporarily

---

### `client.scanner.log.check-crc` {#client-scanner-log-check-crc}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Client

Automatically check the CRC3 of the read records for LogScanner. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.

---

### `client.scanner.log.fetch.max-bytes` {#client-scanner-log-fetch-max-bytes}

* **Default**: `16 mb`
* **Type**: MemorySize
* **Scope**: Client

The maximum amount of data the server should return for a fetch request from client. Records are fetched in batches, and if the first record batch in the first non-empty bucket of the fetch is larger than this value, the record batch will still be returned to ensure that the fetch can make progress. As such, this is not a absolute maximum.

---

### `client.scanner.log.fetch.max-bytes-for-bucket` {#client-scanner-log-fetch-max-bytes-for-bucket}

* **Default**: `1 mb`
* **Type**: MemorySize
* **Scope**: Client

The maximum amount of data the server should return for a table bucket in fetch request from client. Records are fetched in batches, the max bytes size is config by this option.

---

### `client.scanner.log.fetch.min-bytes` {#client-scanner-log-fetch-min-bytes}

* **Default**: `1 bytes`
* **Type**: MemorySize
* **Scope**: Client

The minimum bytes expected for each fetch log request from client to response. If not enough bytes, wait up to client.scanner.log.fetch.wait-max-time time to return.

---

### `client.scanner.log.fetch.wait-max-time` {#client-scanner-log-fetch-wait-max-time}

* **Default**: `PT0.5S`
* **Type**: Duration
* **Scope**: Client

The maximum time to wait for enough bytes to be available for a fetch log request from client to response.

---

### `client.scanner.log.max-poll-records` {#client-scanner-log-max-poll-records}

* **Default**: `500`
* **Type**: Int
* **Scope**: Client

The maximum number of records returned in a single call to poll() for LogScanner. Note that this config doesn't impact the underlying fetching behavior. The Scanner will cache the records from each fetch request and returns them incrementally from each poll.

---

### `client.scanner.remote-log.prefetch-num` {#client-scanner-remote-log-prefetch-num}

* **Default**: `4`
* **Type**: Int
* **Scope**: Client

The number of remote log segments to keep in local temp file for LogScanner, which download from remote storage. The default setting is 4.

---

### `client.security.protocol` {#client-security-protocol}

* **Default**: `PLAINTEXT`
* **Type**: String
* **Scope**: Client

The authentication protocol used to authenticate the client.

---

### `client.security.sasl.jaas.config` {#client-security-sasl-jaas-config}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Client

JAAS configuration string for the client. If not provided, uses the JVM option -Djava.security.auth.login.config.  Example: org.apache.fluss.security.auth.sasl.plain.PlainLoginModule required username="admin" password="admin-secret";

---

### `client.security.sasl.mechanism` {#client-security-sasl-mechanism}

* **Default**: `PLAIN`
* **Type**: String
* **Scope**: Client

SASL mechanism to use for authentication.Currently, we only support plain.

---

### `client.security.sasl.password` {#client-security-sasl-password}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Client

The username to use for client-side SASL JAAS authentication. This is used when the client connects to the Fluss cluster with SASL authentication enabled. If not provided, the password will be read from the JAAS configuration string specified by `client.security.sasl.jaas.config`.

---

### `client.security.sasl.username` {#client-security-sasl-username}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Client

The password to use for client-side SASL JAAS authentication. This is used when the client connects to the Fluss cluster with SASL authentication enabled. If not provided, the username will be read from the JAAS configuration string specified by `client.security.sasl.jaas.config`.

---

### `client.writer.acks` {#client-writer-acks}

* **Default**: `all`
* **Type**: String
* **Scope**: Client

The number of acknowledgments the writer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are allowed: acks=0: If set to 0, then the writer will not wait for any acknowledgment from the server at all. No guarantee can be mode that the server has received the record in this case. acks=1: This will mean the leader will write the record to its local log but will respond without awaiting full acknowledge the record but before the followers have replicated it then the record will be lost. acks=-1 (all): This will mean the leader will wait for the full ser of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive, This is the strongest available guarantee.

---

### `client.writer.batch-size` {#client-writer-batch-size}

* **Default**: `2 mb`
* **Type**: MemorySize
* **Scope**: Client

The writer or walBuilder will attempt to batch records together into one batch for the same bucket. This helps performance on both the client and the server.

---

### `client.writer.batch-timeout` {#client-writer-batch-timeout}

* **Default**: `PT0.1S`
* **Type**: Duration
* **Scope**: Client

The writer groups ay rows that arrive in between request sends into a single batched request. Normally this occurs only under load when rows arrive faster than they can be sent out. However in some circumstances the writer may want toreduce the number of requests even under moderate load. This setting accomplishes this by adding a small amount of artificial delay, that is, rather than immediately sending out a row, the writer will wait for up to the given delay to allow other records to be sent so that the sends can be batched together. This can be thought of as analogous to Nagle's algorithm in TCP. This setting gives the upper bound on the delay for batching: once we get client.writer.batch-size worth of rows for a bucket it will be sent immediately regardless of this setting, however if we have fewer than this many bytes accumulated for this bucket we will delay for the specified time waiting for more records to show up.

---

### `client.writer.bucket.no-key-assigner` {#client-writer-bucket-no-key-assigner}

* **Default**: `STICKY`
* **Type**: ConfigOptionsNoKeyAssigner
* **Scope**: Client

The bucket assigner for no key table. For table with bucket key or primary key, we choose a bucket based on a hash of the key. For these table without bucket key and primary key, we can use this option to specify bucket assigner, the candidate assigner is [ROUND_ROBIN, STICKY], the default assigner is STICKY. ROUND_ROBIN: this strategy will assign the bucket id for the input row by round robin. STICKY: this strategy will assign new bucket id only if the batch changed in record accumulator, otherwise the bucket id will be the same as the front record.

---

### `client.writer.buffer.memory-size` {#client-writer-buffer-memory-size}

* **Default**: `64 mb`
* **Type**: MemorySize
* **Scope**: Client

The total bytes of memory the writer can use to buffer internal rows.

---

### `client.writer.buffer.page-size` {#client-writer-buffer-page-size}

* **Default**: `128 kb`
* **Type**: MemorySize
* **Scope**: Client

Size of every page in memory buffers (`client.writer.buffer.memory-size`).

---

### `client.writer.buffer.per-request-memory-size` {#client-writer-buffer-per-request-memory-size}

* **Default**: `16 mb`
* **Type**: MemorySize
* **Scope**: Client

The minimum number of bytes that will be allocated by the writer rounded down to the closes multiple of client.writer.buffer.page-sizeIt must be greater than or equal to client.writer.buffer.page-size. This option allows to allocate memory in batches to have better CPU-cached friendliness due to contiguous segments.

---

### `client.writer.buffer.wait-timeout` {#client-writer-buffer-wait-timeout}

* **Default**: `PT2562047H47M16.854775807S`
* **Type**: Duration
* **Scope**: Client

Defines how long the writer will block when waiting for segments to become available.

---

### `client.writer.dynamic-batch-size.enabled` {#client-writer-dynamic-batch-size-enabled}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Client

Controls whether the client writer dynamically adjusts the batch size based on actual write throughput. Enabled by default. With dynamic batch sizing enabled, the writer adapts memory allocation per batch according to historical write sizes for the target table or partition. This ensures better memory utilization and performance under varying throughput conditions. The dynamic batch size is bounded: it will not exceed `client.writer.batch-size`, nor fall below `client.writer.buffer.page-size`.When disabled, the writer uses a fixed batch size (`client.writer.batch-size`) for all batches, this may lead to frequent memory waits and suboptimal write performance if the incoming data rate is inconsistent across partitions.

---

### `client.writer.dynamic-create-partition.enabled` {#client-writer-dynamic-create-partition-enabled}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Client

Whether enable dynamic create partition for client writer. Enable by default. Dynamic partition strategy refers to creating partitions based on the data being written for partitioned table if the wrote partition don't exists.

---

### `client.writer.enable-idempotence` {#client-writer-enable-idempotence}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Client

Enable idempotence for the writer. When idempotence is enabled, the writer will ensure that exactly one copy of each record is written in the stream. When idempotence is disabled, the writer retries due to server failures, etc., may write duplicates of the retried record in the stream. Note that enabling writer idempotence requires client.writer.retries to be greater than 0, and client.writer.acks must be `all`. Writer idempotence is enabled by default if no conflicting config are set. If conflicting config are set and writer idempotence is not explicitly enabled, idempotence is disabled. If idempotence is explicitly enabled and conflicting config are set, a ConfigException is thrown

---

### `client.writer.max-inflight-requests-per-bucket` {#client-writer-max-inflight-requests-per-bucket}

* **Default**: `5`
* **Type**: Int
* **Scope**: Client

The maximum number of unacknowledged requests per bucket for writer. This configuration can work only if client.writer.enable-idempotence is set to true. When the number of inflight requests per bucket exceeds this setting, the writer will wait for the inflight requests to complete before sending out new requests.

---

### `client.writer.request-max-size` {#client-writer-request-max-size}

* **Default**: `10 mb`
* **Type**: MemorySize
* **Scope**: Client

The maximum size of a request in bytes. This setting will limit the number of record batches the writer will send in a single request to avoid sending huge requests. Note that this retry is no different than if the writer resent the row upon receiving the error.

---

### `client.writer.retries` {#client-writer-retries}

* **Default**: `2147483647`
* **Type**: Int
* **Scope**: Client

Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error.

---

## Coordinator Configurations

### `coordinator.host` {#coordinator-host}

> **Warning**: This configuration is **Deprecated**.

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The config parameter defining the network address to connect to for communication with the coordinator server. If the coordinator server is used as a bootstrap server (discover all the servers in the cluster), the value of this config option should be a static hostname or address.This option is deprecated. Please use bind.listeners instead, which provides a more flexible configuration for multiple ports

---

### `coordinator.io-pool.size` {#coordinator-io-pool-size}

> **Warning**: This configuration is **Deprecated**.

* **Default**: `10`
* **Type**: Int
* **Scope**: Server

The size of the IO thread pool to run blocking operations for coordinator server. This includes discard unnecessary snapshot files. Increase this value if you experience slow unnecessary snapshot files clean. The default value is 10. This option is deprecated. Please use server.io-pool.size instead.

---

### `coordinator.port` {#coordinator-port}

> **Warning**: This configuration is **Deprecated**.

* **Default**: `9123`
* **Type**: String
* **Scope**: Server

The config parameter defining the network port to connect to for communication with the coordinator server. Like coordinator.host, if the coordinator server is used as a bootstrap server (discover all the servers in the cluster), the value of this config option should be a static port. Otherwise, the value can be set to "0" for a dynamic service name resolution. The value accepts a list of ports (“50100,50101”), ranges (“50100-50200”) or a combination of both.This option is deprecated. Please use bind.listeners instead, which provides a more flexible configuration for multiple ports

---

### `coordinator.producer-offsets.cleanup-interval` {#coordinator-producer-offsets-cleanup-interval}

* **Default**: `PT1H`
* **Type**: Duration
* **Scope**: Server

The interval for cleaning up expired producer offsets and orphan files in remote storage. The cleanup task runs periodically to remove expired offsets and any orphan files that may have been left behind due to incomplete operations. The default value is 1 hour.

---

### `coordinator.producer-offsets.ttl` {#coordinator-producer-offsets-ttl}

* **Default**: `PT24H`
* **Type**: Duration
* **Scope**: Server

The TTL (time-to-live) for producer offsets. Producer offsets older than this TTL will be automatically cleaned up by the coordinator server. Producer offsets are used for undo recovery when a Flink job fails over before completing its first checkpoint. The default value is 24 hours.

---

## Data Configurations

### `data.dir` {#data-dir}

* **Default**: `/tmp/fluss-data`
* **Type**: String
* **Scope**: Server

This configuration controls the directory where Fluss will store its data. The default value is /tmp/fluss-data

---

## Datalake Configurations

### `datalake.format` {#datalake-format}

* **Default**: `(none)`
* **Type**: DataLakeFormat
* **Scope**: Server

The datalake format used by of Fluss to be as lakehouse storage. Currently, supported formats are Paimon, Iceberg, and Lance. In the future, more kinds of data lake format will be supported, such as DeltaLake or Hudi.

---

## Default Configurations

### `default.bucket.number` {#default-bucket-number}

* **Default**: `1`
* **Type**: Int
* **Scope**: Server

The default number of buckets for a table in Fluss cluster. It's a cluster-level parameter, and all the tables without specifying bucket number in the cluster will use the value as the bucket number.

---

### `default.replication.factor` {#default-replication-factor}

* **Default**: `1`
* **Type**: Int
* **Scope**: Server

The default replication factor for the log of a table in Fluss cluster. It's a cluster-level parameter, and all the tables without specifying replication factor in the cluster will use the value as replication factor.

---

## Internal Configurations

### `internal.listener.name` {#internal-listener-name}

* **Default**: `FLUSS`
* **Type**: String
* **Scope**: Server

The listener for server internal communication.

---

## Kafka Configurations

### `kafka.connection.max-idle-time` {#kafka-connection-max-idle-time}

* **Default**: `PT1M`
* **Type**: Duration
* **Scope**: Server

Close kafka idle connections after the given time specified by this config.

---

### `kafka.database` {#kafka-database}

* **Default**: `kafka`
* **Type**: String
* **Scope**: Server

The database for Fluss Kafka. The default database is `kafka`.

---

### `kafka.enabled` {#kafka-enabled}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

Whether enable Fluss Kafka. Disabled by default. When this option is set to true, the Fluss Kafka will be enabled.

---

### `kafka.listener.names` {#kafka-listener-names}

* **Default**: `[KAFKA]`
* **Type**: String
* **Scope**: Server

The listener names for Kafka wire protocol communication. Support multiple listener names, separated by comma.

---

## Kv Configurations

### `kv.recover.log-record-batch.max-size` {#kv-recover-log-record-batch-max-size}

* **Default**: `16 mb`
* **Type**: MemorySize
* **Scope**: Server

The max fetch size for fetching log to apply to kv during recovering kv.

---

### `kv.rocksdb.block.blocksize` {#kv-rocksdb-block-blocksize}

* **Default**: `4 kb`
* **Type**: MemorySize
* **Scope**: Server

The approximate size (in bytes) of user data packed per block. The default blocksize is `4KB`.

---

### `kv.rocksdb.block.cache-index-and-filter-blocks` {#kv-rocksdb-block-cache-index-and-filter-blocks}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

If true, index and filter blocks will be stored in block cache, together with all other data blocks. This helps to limit memory usage so that the total memory used by RocksDB is bounded by block cache size. The default value is `false`.

---

### `kv.rocksdb.block.cache-index-and-filter-blocks-with-high-priority` {#kv-rocksdb-block-cache-index-and-filter-blocks-with-high-priority}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

If true and cache_index_and_filter_blocks is enabled, index and filter blocks will be stored with high priority in block cache, making them less likely to be evicted than data blocks. The default value is `false`.

---

### `kv.rocksdb.block.cache-size` {#kv-rocksdb-block-cache-size}

* **Default**: `8 mb`
* **Type**: MemorySize
* **Scope**: Server

The amount of the cache for data blocks in RocksDB. The default block-cache size is `8MB`.

---

### `kv.rocksdb.block.metadata-blocksize` {#kv-rocksdb-block-metadata-blocksize}

* **Default**: `4 kb`
* **Type**: MemorySize
* **Scope**: Server

Approximate size of partitioned metadata packed per block. Currently applied to indexes block when partitioned index/filters option is enabled. The default blocksize is `4KB`.

---

### `kv.rocksdb.block.pin-l0-filter-and-index-blocks-in-cache` {#kv-rocksdb-block-pin-l0-filter-and-index-blocks-in-cache}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

If true and cache_index_and_filter_blocks is enabled, L0 index and filter blocks will be pinned in block cache and will not be evicted. This helps avoid performance degradation due to cache misses on L0 index/filter blocks. The default value is `false`.

---

### `kv.rocksdb.block.pin-top-level-index-and-filter` {#kv-rocksdb-block-pin-top-level-index-and-filter}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

If true, the top-level index of partitioned index/filter blocks will be pinned in block cache and will not be evicted. The default value is `false`.

---

### `kv.rocksdb.bloom-filter.bits-per-key` {#kv-rocksdb-bloom-filter-bits-per-key}

* **Default**: `10.0`
* **Type**: Double
* **Scope**: Server

Bits per key that bloom filter will use, this only take effect when bloom filter is used. The default value is 10.0.

---

### `kv.rocksdb.bloom-filter.block-based-mode` {#kv-rocksdb-bloom-filter-block-based-mode}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

If true, RocksDB will use block-based filter instead of full filter, this only take effect when bloom filter is used. The default value is `false`.

---

### `kv.rocksdb.compaction.level.max-size-level-base` {#kv-rocksdb-compaction-level-max-size-level-base}

* **Default**: `256 mb`
* **Type**: MemorySize
* **Scope**: Server

The upper-bound of the total size of level base files in bytes. The default value is `256MB`.

---

### `kv.rocksdb.compaction.level.target-file-size-base` {#kv-rocksdb-compaction-level-target-file-size-base}

* **Default**: `64 mb`
* **Type**: MemorySize
* **Scope**: Server

The target file size for compaction, which determines a level-1 file size. The default value is `64MB`.

---

### `kv.rocksdb.compaction.level.use-dynamic-size` {#kv-rocksdb-compaction-level-use-dynamic-size}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

If true, RocksDB will pick target size of each level dynamically. From an empty DB, RocksDB would make last level the base level, which means merging L0 data into the last level, until it exceeds max_bytes_for_level_base. And then repeat this process for second last level and so on. The default value is `false`. For more information, please refer to true https://github.com/facebook/rocksdb/wiki/Leveled-Compaction#level_compaction_dynamic_level_bytes-is-trueRocksDB's doc.

---

### `kv.rocksdb.compaction.style` {#kv-rocksdb-compaction-style}

* **Default**: `LEVEL`
* **Type**: ConfigOptionsCompactionStyle
* **Scope**: Server

The specified compaction style for DB. Candidate compaction style is LEVEL, FIFO, UNIVERSAL or NONE, and Fluss chooses `LEVEL` as default style.

---

### `kv.rocksdb.compression.per.level` {#kv-rocksdb-compression-per-level}

* **Default**: `[LZ4, LZ4, LZ4, LZ4, LZ4, ZSTD, ZSTD]`
* **Type**: ConfigOptionsKvCompressionType
* **Scope**: Server

A comma-separated list of Compression Type. Different levels can have different compression policies. In many cases, lower levels use fast compression algorithms, while higher levels with more data use slower but more effective compression algorithms. The N th element in the List corresponds to the compression type of the level N-1When `kv.rocksdb.compaction.level.use-dynamic-size` is true, compression_per_level[0] still determines L0, but other elements are based on the base level and may not match the level seen in the info log. Note: If the List size is smaller than the level number, the undefined lower level uses the last Compression Type in the List. The optional values include NO, SNAPPY, LZ4, ZSTD. For more information about compression type, please refer to doc https://github.com/facebook/rocksdb/wiki/Compression. The default value is ‘LZ4,LZ4,LZ4,LZ4,LZ4,ZSTD,ZSTD’, indicates there is lz4 compaction of level0 and level4，ZSTD compaction algorithm is used from level5 to level6. LZ4 is a lightweight compression algorithm so it usually strikes a good balance between space and CPU usage.  ZSTD is more space save than LZ4, but it is more CPU-intensive. Different machines deploy compaction modes according to CPU and I/O resources. The default value is for the scenario that CPU resources are adequate. If you find the IO pressure of the system is not big when writing a lot of data, but CPU resources are inadequate, you can exchange I/O resources for CPU resources and change the compaction mode to `NO,NO,NO,LZ4,LZ4,ZSTD,ZSTD`. 

---

### `kv.rocksdb.files.open` {#kv-rocksdb-files-open}

* **Default**: `-1`
* **Type**: Int
* **Scope**: Server

The maximum number of open files (per  bucket of table) that can be used by the DB, `-1` means no limit. The default value is `-1`.

---

### `kv.rocksdb.log.dir` {#kv-rocksdb-log-dir}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The directory for RocksDB's information logging files. If empty (Fluss default setting), log files will be in the same directory as the Fluss log. If non-empty, this directory will be used and the data directory's absolute path will be used as the prefix of the log file name. If setting this option as a non-existing location, e.g `/dev/null`, RocksDB will then create the log under its own database folder as before.

---

### `kv.rocksdb.log.file-num` {#kv-rocksdb-log-file-num}

* **Default**: `4`
* **Type**: Int
* **Scope**: Server

The maximum number of files RocksDB should keep for information logging (Default setting: 4).

---

### `kv.rocksdb.log.level` {#kv-rocksdb-log-level}

* **Default**: `INFO_LEVEL`
* **Type**: ConfigOptionsInfoLogLevel
* **Scope**: Server

The specified information logging level for RocksDB. Candidate log level is [DEBUG_LEVEL, INFO_LEVEL, WARN_LEVEL, ERROR_LEVEL, FATAL_LEVEL, HEADER_LEVEL, NUM_INFO_LOG_LEVELS]. If unset, Fluss will use INFO_LEVEL. Note: RocksDB info logs will not be written to the Fluss's tablet server logs and there is no rolling strategy, unless you configure kv.rocksdb.log.dir, kv.rocksdb.log.max-file-size, and kv.rocksdb.log.file-num accordingly. Without a rolling strategy, it may lead to uncontrolled disk space usage if configured with increased log levels! There is no need to modify the RocksDB log level, unless for troubleshooting RocksDB.

---

### `kv.rocksdb.log.max-file-size` {#kv-rocksdb-log-max-file-size}

* **Default**: `25 mb`
* **Type**: MemorySize
* **Scope**: Server

The maximum size of RocksDB's file used for information logging. If the log files becomes larger than this, a new file will be created. If 0, all logs will be written to one log file. The default maximum file size is `25MB`. 

---

### `kv.rocksdb.shared-rate-limiter.bytes-per-sec` {#kv-rocksdb-shared-rate-limiter-bytes-per-sec}

* **Default**: `9223372036854775807 bytes`
* **Type**: MemorySize
* **Scope**: Server

The bytes per second rate limit for RocksDB flush and compaction operations shared across all RocksDB instances on the TabletServer. The rate limiter is always enabled. The default value is Long.MAX_VALUE (effectively unlimited). Set to a lower value (e.g., 100MB) to limit the rate. This configuration can be updated dynamically without server restart. See [Updating Configs](operations/updating-configs.md) for more details.

---

### `kv.rocksdb.thread.num` {#kv-rocksdb-thread-num}

* **Default**: `2`
* **Type**: Int
* **Scope**: Server

The maximum number of concurrent background flush and compaction jobs (per bucket of table). The default value is `2`.

---

### `kv.rocksdb.use-bloom-filter` {#kv-rocksdb-use-bloom-filter}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Server

If true, every newly created SST file will contain a Bloom filter. It is enabled by default.

---

### `kv.rocksdb.write-batch-size` {#kv-rocksdb-write-batch-size}

* **Default**: `2 mb`
* **Type**: MemorySize
* **Scope**: Server

The max size of the consumed memory for RocksDB batch write, will flush just based on item count if this config set to 0.

---

### `kv.rocksdb.writebuffer.count` {#kv-rocksdb-writebuffer-count}

* **Default**: `2`
* **Type**: Int
* **Scope**: Server

The maximum number of write buffers that are built up in memory. The default value is `2`.

---

### `kv.rocksdb.writebuffer.number-to-merge` {#kv-rocksdb-writebuffer-number-to-merge}

* **Default**: `1`
* **Type**: Int
* **Scope**: Server

The minimum number of write buffers that will be merged together before writing to storage. The default value is `1`.

---

### `kv.rocksdb.writebuffer.size` {#kv-rocksdb-writebuffer-size}

* **Default**: `64 mb`
* **Type**: MemorySize
* **Scope**: Server

The amount of data built up in memory (backed by an unsorted log on disk) before converting to a sorted on-disk files. The default writebuffer size is `64MB`.

---

### `kv.snapshot.interval` {#kv-snapshot-interval}

* **Default**: `PT10M`
* **Type**: Duration
* **Scope**: Server

The interval to perform periodic snapshot for kv data. The default setting is 10 minutes.

---

### `kv.snapshot.num-retained` {#kv-snapshot-num-retained}

* **Default**: `1`
* **Type**: Int
* **Scope**: Server

The maximum number of completed snapshots to retain.

---

### `kv.snapshot.scheduler-thread-num` {#kv-snapshot-scheduler-thread-num}

* **Default**: `1`
* **Type**: Int
* **Scope**: Server

The number of threads that the server uses to schedule snapshot kv data for all the replicas in the server.

---

### `kv.snapshot.transfer-thread-num` {#kv-snapshot-transfer-thread-num}

> **Warning**: This configuration is **Deprecated**.

* **Default**: `4`
* **Type**: Int
* **Scope**: Server

The number of threads the server uses to transfer (download and upload) kv snapshot files. This option is deprecated. Please use server.io-pool.size instead.

---

## Lake Configurations

### `lake.tiering.auto-expire-snapshot` {#lake-tiering-auto-expire-snapshot}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

If true, snapshot expiration will be triggered automatically when tiering service commits to the datalake, even if Key: 'table.datalake.auto-expire-snapshot' , default: false (fallback keys: []) is false.

---

## Log Configurations

### `log.file-preallocate` {#log-file-preallocate}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

True if we should preallocate the file on disk when creating a new log segment.

---

### `log.flush.interval-messages` {#log-flush-interval-messages}

* **Default**: `9223372036854775807`
* **Type**: Long
* **Scope**: Server

This setting allows specifying an interval at which we will force a fsync of data written to the log. For example if this was set to 1, we would fsync after every message; if it were 5 we would fsync after every five messages.

---

### `log.index.file-size` {#log-index-file-size}

* **Default**: `10 mb`
* **Type**: MemorySize
* **Scope**: Server

This configuration controls the size of the index that maps offsets to file positions. We preallocate this index file and shrink it only after log rolls. You generally should not need to change this setting.

---

### `log.index.interval-size` {#log-index-interval-size}

* **Default**: `4 kb`
* **Type**: MemorySize
* **Scope**: Server

This setting controls how frequently Fluss adds an index entry to its offset index. The default setting ensures that we index a message roughly every 4096 bytes. More indexing allows reads to jump closer to the exact position in the log but makes the index larger. You probably don't need to change this.

---

### `log.replica.fetch-operation-purge-number` {#log-replica-fetch-operation-purge-number}

* **Default**: `1000`
* **Type**: Int
* **Scope**: Server

The purge number (in number of requests) of the fetch log operation manager, the default value is 1000.

---

### `log.replica.fetch.backoff-interval` {#log-replica-fetch-backoff-interval}

* **Default**: `PT1S`
* **Type**: Duration
* **Scope**: Server

The amount of time to sleep when fetch bucket error occurs.

---

### `log.replica.fetch.max-bytes` {#log-replica-fetch-max-bytes}

* **Default**: `16 mb`
* **Type**: MemorySize
* **Scope**: Server

The maximum amount of data the server should return for a fetch request from follower. Records are fetched in batches, and if the first record batch in the first non-empty bucket of the fetch is larger than this value, the record batch will still be returned to ensure that the fetch can make progress. As such, this is not a absolute maximum. Note that the fetcher performs multiple fetches in parallel.

---

### `log.replica.fetch.max-bytes-for-bucket` {#log-replica-fetch-max-bytes-for-bucket}

* **Default**: `1 mb`
* **Type**: MemorySize
* **Scope**: Server

The maximum amount of data the server should return for a table bucket in fetch request from follower. Records are fetched in batches, and the max bytes size is config by this option.

---

### `log.replica.fetch.min-bytes` {#log-replica-fetch-min-bytes}

* **Default**: `1 bytes`
* **Type**: MemorySize
* **Scope**: Server

The minimum bytes expected for each fetch log request from the follower to response. If not enough bytes, wait up to log.replica.fetch.wait-max-time time to return.

---

### `log.replica.fetch.wait-max-time` {#log-replica-fetch-wait-max-time}

* **Default**: `PT0.5S`
* **Type**: Duration
* **Scope**: Server

The maximum time to wait for enough bytes to be available for a fetch log request from the follower to response. This value should always be less than the `log.replica.max-lag-time` at all times to prevent frequent shrinking of ISR for low throughput tables

---

### `log.replica.fetcher-number` {#log-replica-fetcher-number}

* **Default**: `1`
* **Type**: Int
* **Scope**: Server

Number of fetcher threads used to replicate log records from each source tablet server. The total number of fetchers on each tablet server is bound by this parameter multiplied by the number of tablet servers in the cluster. Increasing this value can increase the degree of I/O parallelism in the follower and leader tablet server at the cost of higher CPU and memory utilization.

---

### `log.replica.high-watermark.checkpoint-interval` {#log-replica-high-watermark-checkpoint-interval}

* **Default**: `PT5S`
* **Type**: Duration
* **Scope**: Server

The frequency with which the high watermark is saved out to disk. The default setting is 5 seconds.

---

### `log.replica.max-lag-time` {#log-replica-max-lag-time}

* **Default**: `PT30S`
* **Type**: Duration
* **Scope**: Server

If a follower replica hasn't sent any fetch log requests or hasn't consumed up the leaders log end offset for at least this time, the leader will remove the follower replica from isr

---

### `log.replica.min-in-sync-replicas-number` {#log-replica-min-in-sync-replicas-number}

* **Default**: `1`
* **Type**: Int
* **Scope**: Server

When a writer set `client.writer.acks` to all (-1), this configuration specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the writer will raise an exception (NotEnoughReplicas). when used together, this config and `client.writer.acks` allow you to enforce greater durability guarantees. A typical scenario would be to create a table with a replication factor of 3. set this conf to 2, and write with acks = -1. This will ensure that the writer raises an exception if a majority of replicas don't receive a write.

---

### `log.replica.write-operation-purge-number` {#log-replica-write-operation-purge-number}

* **Default**: `1000`
* **Type**: Int
* **Scope**: Server

The purge number (in number of requests) of the write operation manager, the default value is 1000.

---

### `log.segment.file-size` {#log-segment-file-size}

* **Default**: `1 gb`
* **Type**: MemorySize
* **Scope**: Server

This configuration controls the segment file size for the log. Retention and cleaning is always done a file at a time so a larger segment size means fewer files but less granular control over retention.

---

## Max Configurations

### `max.bucket.num` {#max-bucket-num}

* **Default**: `128000`
* **Type**: Int
* **Scope**: Server

The maximum number of buckets that can be created for a table. The default value is 128000.

---

### `max.partition.num` {#max-partition-num}

* **Default**: `1000`
* **Type**: Int
* **Scope**: Server

Limits the maximum number of partitions that can be created for a partitioned table to avoid creating too many partitions.

---

## Metrics Configurations

### `metrics.reporter.jmx.port` {#metrics-reporter-jmx-port}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The port for the JMXServer that JMX clients can connect to. If not set, the JMXServer won't start. In order to be able to run several instances of the reporter on one host (e.g. when one TabletServer is colocated with the CoordinatorServer) it is advisable to use a port range like 9990-9999.

---

### `metrics.reporter.prometheus-push.delete-on-shutdown` {#metrics-reporter-prometheus-push-delete-on-shutdown}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Server

Specifies whether to delete metrics from the PushGateway on shutdown, defaults to true. Fluss will try its best to delete the metrics but this is not guaranteed.

---

### `metrics.reporter.prometheus-push.grouping-key` {#metrics-reporter-prometheus-push-grouping-key}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

Specifies the grouping key which is the group and global labels of all metrics. The label name and value are separated by '=', and labels are separated by ';', e.g., k1=v1;k2=v2.

---

### `metrics.reporter.prometheus-push.host-url` {#metrics-reporter-prometheus-push-host-url}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The PushGateway server host URL including scheme, host name, and port.

---

### `metrics.reporter.prometheus-push.job-name` {#metrics-reporter-prometheus-push-job-name}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The job name under which metrics will be pushed

---

### `metrics.reporter.prometheus-push.push-interval` {#metrics-reporter-prometheus-push-push-interval}

* **Default**: `PT10S`
* **Type**: Duration
* **Scope**: Server

The interval of pushing metrics to Prometheus PushGateway, defaults to 10 SECONDS.

---

### `metrics.reporter.prometheus-push.random-job-name-suffix` {#metrics-reporter-prometheus-push-random-job-name-suffix}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Server

Specifies whether a random suffix should be appended to the job name, defaults to true. This is useful when multiple instances of the reporter are running on the same host.

---

### `metrics.reporter.prometheus.port` {#metrics-reporter-prometheus-port}

* **Default**: `9249`
* **Type**: String
* **Scope**: Server

The port the Prometheus reporter listens on.In order to be able to run several instances of the reporter on one host (e.g. when one TabletServer is colocated with the CoordinatorServer) it is advisable to use a port range like 9250-9260.

---

### `metrics.reporters` {#metrics-reporters}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

An optional list of reporter names. If configured, only reporters whose name matches in the list will be started

---

## Netty Configurations

### `netty.client.num-network-threads` {#netty-client-num-network-threads}

* **Default**: `4`
* **Type**: Int
* **Scope**: Server

The number of threads that the client uses for sending requests to the network and receiving responses from network. The default value is 4

---

### `netty.connection.max-idle-time` {#netty-connection-max-idle-time}

* **Default**: `PT10M`
* **Type**: Duration
* **Scope**: Server

Close idle connections after the given time specified by this config.

---

### `netty.server.max-queued-requests` {#netty-server-max-queued-requests}

* **Default**: `500`
* **Type**: Int
* **Scope**: Server

The number of queued requests allowed for worker threads, before blocking the I/O threads.

---

### `netty.server.num-network-threads` {#netty-server-num-network-threads}

* **Default**: `3`
* **Type**: Int
* **Scope**: Server

The number of threads that the server uses for receiving requests from the network and sending responses to the network.

---

### `netty.server.num-worker-threads` {#netty-server-num-worker-threads}

* **Default**: `8`
* **Type**: Int
* **Scope**: Server

The number of threads that the server uses for processing requests, which may include disk and remote I/O.

---

## Plugin Configurations

### `plugin.classloader.parent-first-patterns.additional` {#plugin-classloader-parent-first-patterns-additional}

* **Default**: `[]`
* **Type**: String
* **Scope**: Server

A (semicolon-separated) list of patterns that specifies which classes should always be resolved through the plugin parent ClassLoader first. A pattern is a simple prefix that is checked  against the fully qualified class name. These patterns are appended to "plugin.classloader.parent-first-patterns.default".

---

### `plugin.classloader.parent-first-patterns.default` {#plugin-classloader-parent-first-patterns-default}

* **Default**: `[java., org.apache.fluss., javax.annotation., org.apache.hadoop., core-site, org.slf4j, org.apache.log4j, org.apache.logging, org.apache.commons.logging, ch.qos.logback]`
* **Type**: String
* **Scope**: Server

A (semicolon-separated) list of patterns that specifies which classes should always be resolved through the plugin parent ClassLoader first. A pattern is a simple prefix that is checked  against the fully qualified class name. This setting should generally not be modified. To add another  pattern we recommend to use "plugin.classloader.parent-first-patterns.additional" instead.

---

## Remote Configurations

### `remote.data.dir` {#remote-data-dir}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The directory used for storing the kv snapshot data files and remote log for log tiered storage  in a Fluss supported filesystem.

---

### `remote.fs.write-buffer-size` {#remote-fs-write-buffer-size}

* **Default**: `4 kb`
* **Type**: MemorySize
* **Scope**: Server

The default size of the write buffer for writing the local files to remote file systems.

---

### `remote.log-manager.thread-pool-size` {#remote-log-manager-thread-pool-size}

* **Default**: `4`
* **Type**: Int
* **Scope**: Server

Size of the thread pool used in scheduling tasks to copy segments, fetch remote log indexes and clean up remote log segments.

---

### `remote.log.data-transfer-thread-num` {#remote-log-data-transfer-thread-num}

> **Warning**: This configuration is **Deprecated**.

* **Default**: `4`
* **Type**: Int
* **Scope**: Server

The number of threads the server uses to transfer (download and upload) remote log file can be  data file, index file and remote log metadata file. This option is deprecated. Please use server.io-pool.size instead.

---

### `remote.log.index-file-cache-size` {#remote-log-index-file-cache-size}

* **Default**: `1 gb`
* **Type**: MemorySize
* **Scope**: Server

The total size of the space allocated to store index files fetched from remote storage in the local storage.

---

### `remote.log.task-interval-duration` {#remote-log-task-interval-duration}

* **Default**: `PT1M`
* **Type**: Duration
* **Scope**: Server

Interval at which remote log manager runs the scheduled tasks like copy segments, clean up remote log segments, delete local log segments etc. If the value is set to 0s, it means that the remote log storage is disabled.

---

## Security Configurations

### `security.protocol.map` {#security-protocol-map}

* **Default**: `{}`
* **Type**: String
* **Scope**: Server

A map defining the authentication protocol for each listener. The format is `listenerName1:protocol1,listenerName2:protocol2`, e.g., `INTERNAL:PLAINTEXT,CLIENT:GSSAPI`. Each listener can be associated with a specific authentication protocol. Listeners not included in the map will use PLAINTEXT by default, which does not require authentication.

---

### `security.sasl.enabled.mechanisms` {#security-sasl-enabled-mechanisms}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server



---

## Server Configurations

### `server.background.threads` {#server-background-threads}

* **Default**: `10`
* **Type**: Int
* **Scope**: Server

The number of threads to use for various background processing tasks. The default value is 10.

---

### `server.buffer.memory-size` {#server-buffer-memory-size}

* **Default**: `256 mb`
* **Type**: MemorySize
* **Scope**: Server

The total bytes of memory the server can use, e.g, buffer write-ahead-log rows.

---

### `server.buffer.page-size` {#server-buffer-page-size}

* **Default**: `128 kb`
* **Type**: MemorySize
* **Scope**: Server

Size of every page in memory buffers (`server.buffer.memory-size`).

---

### `server.buffer.per-request-memory-size` {#server-buffer-per-request-memory-size}

* **Default**: `16 mb`
* **Type**: MemorySize
* **Scope**: Server

The minimum number of bytes that will be allocated by the writer rounded down to the closest multiple of server.buffer.page-size. It must be greater than or equal to server.buffer.page-size. This option allows to allocate memory in batches to have better CPU-cached friendliness due to contiguous segments.

---

### `server.buffer.wait-timeout` {#server-buffer-wait-timeout}

* **Default**: `PT2562047H47M16.854775807S`
* **Type**: Duration
* **Scope**: Server

Defines how long the buffer pool will block when waiting for segments.

---

### `server.io-pool.size` {#server-io-pool-size}

* **Default**: `10`
* **Type**: Int
* **Scope**: Server

The size of the IO thread pool to run blocking operations for both coordinator and tablet servers. This includes discard unnecessary snapshot files, transfer kv snapshot files, and transfer remote log files. Increase this value if you experience slow IO operations. The default value is 10.

---

### `server.writer-id.expiration-check-interval` {#server-writer-id-expiration-check-interval}

* **Default**: `PT10M`
* **Type**: Duration
* **Scope**: Server

The interval at which to remove writer ids that have expired due to server.writer-id.expiration-time passing. The default value is 10 minutes.

---

### `server.writer-id.expiration-time` {#server-writer-id-expiration-time}

* **Default**: `PT168H`
* **Type**: Duration
* **Scope**: Server

The time that the tablet server will wait without receiving any write request from a client before expiring the related status. The default value is 7 days.

---

## Super Configurations

### `super.users` {#super-users}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

A semicolon-separated list of superusers who have unrestricted access to all operations and resources. Note that the delimiter is semicolon since SSL user names may contain comma, and each super user should be specified in the format `principal_type:principal_name`, e.g., `User:admin;User:bob`. This configuration is critical for defining administrative privileges in the system.

---

## Table Configurations

### `table.auto-increment.cache-size` {#table-auto-increment-cache-size}

* **Default**: `100000`
* **Type**: Long
* **Scope**: Table

The cache size of auto-increment IDs fetched from the distributed counter each time. This value determines the length of the locally cached ID segment. Default: 100000. A larger cache size may cause significant auto-increment ID gaps, especially when unused cached ID segments are discarded due to TabletServer restarts or abnormal terminations. Conversely, a smaller cache size increases the frequency of ID fetch requests to the distributed counter, introducing extra network overhead and reducing write throughput and performance.

---

### `table.auto-partition.enabled` {#table-auto-partition-enabled}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Table

Whether enable auto partition for the table. Disable by default. When auto partition is enabled, the partitions of the table will be created automatically.

---

### `table.auto-partition.key` {#table-auto-partition-key}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Table

This configuration defines the time-based partition key to be used for auto-partitioning when a table is partitioned with multiple keys. Auto-partitioning utilizes a time-based partition key to handle partitions automatically, including creating new ones and removing outdated ones, by comparing the time value of the partition with the current system time. In the case of a table using multiple partition keys (such as a composite partitioning strategy), this feature determines which key should serve as the primary time dimension for making auto-partitioning decisions.And If the table has only one partition key, this config is not necessary. Otherwise, it must be specified.

---

### `table.auto-partition.num-precreate` {#table-auto-partition-num-precreate}

* **Default**: `2`
* **Type**: Int
* **Scope**: Table

The number of partitions to pre-create for auto created partitions in each check for auto partition. For example, if the current check time is 2024-11-11 and the value is configured as 3, then partitions 20241111, 20241112, 20241113 will be pre-created. If any one partition exists, it'll skip creating the partition. The default value is 2, which means 2 partitions will be pre-created. If the `table.auto-partition.time-unit` is `DAY`(default), one precreated partition is for today and another one is for tomorrow.For a partition table with multiple partition keys, pre-create is unsupported and will be set to 0 automatically when creating table if it is not explicitly specified.

---

### `table.auto-partition.num-retention` {#table-auto-partition-num-retention}

* **Default**: `7`
* **Type**: Int
* **Scope**: Table

The number of history partitions to retain for auto created partitions in each check for auto partition. For example, if the current check time is 2024-11-11, time-unit is DAY, and the value is configured as 3, then the history partitions 20241108, 20241109, 20241110 will be retained. The partitions earlier than 20241108 will be deleted. The default value is 7.

---

### `table.auto-partition.time-unit` {#table-auto-partition-time-unit}

* **Default**: `DAY`
* **Type**: AutoPartitionTimeUnit
* **Scope**: Table

The time granularity for auto created partitions. The default value is `DAY`. Valid values are `HOUR`, `DAY`, `MONTH`, `QUARTER`, `YEAR`. If the value is `HOUR`, the partition format for auto created is yyyyMMddHH. If the value is `DAY`, the partition format for auto created is yyyyMMdd. If the value is `MONTH`, the partition format for auto created is yyyyMM. If the value is `QUARTER`, the partition format for auto created is yyyyQ. If the value is `YEAR`, the partition format for auto created is yyyy.

---

### `table.auto-partition.time-zone` {#table-auto-partition-time-zone}

* **Default**: `Etc/UTC`
* **Type**: String
* **Scope**: Table

The time zone for auto partitions, which is by default the same as the system time zone.

---

### `table.changelog.image` {#table-changelog-image}

* **Default**: `FULL`
* **Type**: ChangelogImage
* **Scope**: Table

Defines the changelog image mode for the primary key table. This configuration is inspired by similar settings in database systems like MySQL's binlog_row_image and PostgreSQL's replica identity. The supported modes are `FULL` (default) and `WAL`. The `FULL` mode produces both UPDATE_BEFORE and UPDATE_AFTER records for update operations, capturing complete information about updates and allowing tracking of previous values. The `WAL` mode does not produce UPDATE_BEFORE records. Only INSERT, UPDATE_AFTER (and DELETE if allowed) records are emitted. When WAL mode is enabled, the default merge engine is used (no merge engine configured), updates are full row updates (not partial update), and there is no auto-increment column, an optimization is applied to skip looking up old values, and in this case INSERT operations are converted to UPDATE_AFTER events. This mode reduces storage and transmission costs but loses the ability to track previous values. This option only affects primary key tables.

---

### `table.datalake.auto-compaction` {#table-datalake-auto-compaction}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Table

If true, compaction will be triggered automatically when tiering service writes to the datalake. It is disabled by default.

---

### `table.datalake.auto-expire-snapshot` {#table-datalake-auto-expire-snapshot}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Table

If true, snapshot expiration will be triggered automatically when tiering service commits to the datalake. It is disabled by default.

---

### `table.datalake.enabled` {#table-datalake-enabled}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Table

Whether enable lakehouse storage for the table. Disabled by default. When this option is set to ture and the datalake tiering service is up, the table will be tiered and compacted into datalake format stored on lakehouse storage.

---

### `table.datalake.format` {#table-datalake-format}

* **Default**: `(none)`
* **Type**: DataLakeFormat
* **Scope**: Table

The data lake format of the table specifies the tiered Lakehouse storage format. Currently, supported formats are `paimon`, `iceberg`, and `lance`. In the future, more kinds of data lake format will be supported, such as DeltaLake or Hudi. Once the `table.datalake.format` property is configured, Fluss adopts the key encoding and bucketing strategy used by the corresponding data lake format. This ensures consistency in key encoding and bucketing, enabling seamless **Union Read** functionality across Fluss and Lakehouse. The `table.datalake.format` can be pre-defined before enabling `table.datalake.enabled`. This allows the data lake feature to be dynamically enabled on the table without requiring table recreation. If `table.datalake.format` is not explicitly set during table creation, the table will default to the format specified by the `datalake.format` configuration in the Fluss cluster.

---

### `table.datalake.freshness` {#table-datalake-freshness}

* **Default**: `PT3M`
* **Type**: Duration
* **Scope**: Table

It defines the maximum amount of time that the datalake table's content should lag behind updates to the Fluss table. Based on this target freshness, the Fluss service automatically moves data from the Fluss table and updates to the datalake table, so that the data in the datalake table is kept up to date within this target. If the data does not need to be as fresh, you can specify a longer target freshness time to reduce costs.

---

### `table.delete.behavior` {#table-delete-behavior}

* **Default**: `ALLOW`
* **Type**: DeleteBehavior
* **Scope**: Table

Defines the delete behavior for the primary key table. The supported delete behaviors are `allow`, `ignore`, and `disable`. The `allow` behavior allows normal delete operations (default for default merge engine). The `ignore` behavior silently skips delete requests without error. The `disable` behavior rejects delete requests with a clear error message. For tables with FIRST_ROW, VERSIONED, or AGGREGATION merge engines, this option defaults to `ignore`. Note: For AGGREGATION merge engine, when set to `allow`, delete operations will remove the entire record.

---

### `table.kv.format` {#table-kv-format}

* **Default**: `COMPACTED`
* **Type**: KvFormat
* **Scope**: Table

The format of the kv records in kv store. The default value is `compacted`. The supported formats are `compacted` and `indexed`.

---

### `table.kv.format-version` {#table-kv-format-version}

* **Default**: `(none)`
* **Type**: Int
* **Scope**: Table

The version of the kv format. Automatically set by the coordinator during table creation if not configured by users. Note: The datalake encoding and bucketing strategy mentioned below only takes effect when 'datalake.format' is configured at cluster level. Version Behaviors: (1) Version 1: Tables created before 'table.kv.format-version' was introduced are treated as version 1. Uses datalake's encoder (e.g., Paimon/Iceberg) for both primary key and bucket key encoding. This may not support prefix lookup properly because some datalake encoders (like Paimon) don't guarantee that encoded bucket key bytes are a prefix of encoded primary key bytes. (2) Version 2 (current): New tables use Fluss's default encoder for primary key encoding when bucket key differs from primary key, which ensures proper prefix lookup support. When bucket key equals primary key (default bucket key), it still uses datalake's encoder for optimization (encoded bytes can be reused for bucket calculation). Bucket key encoding always uses datalake's encoder to align with datalake bucket calculation.

---

### `table.log.arrow.compression.type` {#table-log-arrow-compression-type}

* **Default**: `ZSTD`
* **Type**: ArrowCompressionType
* **Scope**: Table

The compression type of the log records if the log format is set to `ARROW`. The candidate compression type is [NONE, LZ4_FRAME, ZSTD]

---

### `table.log.arrow.compression.zstd.level` {#table-log-arrow-compression-zstd-level}

* **Default**: `3`
* **Type**: Int
* **Scope**: Table

The compression level of ZSTD for the log records if the log format is set to `ARROW` and the compression type is set to `ZSTD`. The valid range is 1 to 22.

---

### `table.log.format` {#table-log-format}

* **Default**: `ARROW`
* **Type**: LogFormat
* **Scope**: Table

The format of the log records in log store. The default value is `arrow`. The supported formats are `arrow`, `indexed` and `compacted`.

---

### `table.log.tiered.local-segments` {#table-log-tiered-local-segments}

* **Default**: `2`
* **Type**: Int
* **Scope**: Table

The number of log segments to retain in local for each table when log tiered storage is enabled. It must be greater that 0. The default is 2.

---

### `table.log.ttl` {#table-log-ttl}

* **Default**: `PT168H`
* **Type**: Duration
* **Scope**: Table

The time to live for log segments. The configuration controls the maximum time we will retain a log before we will delete old segments to free up space. If set to -1, the log will not be deleted.

---

### `table.merge-engine` {#table-merge-engine}

* **Default**: `(none)`
* **Type**: MergeEngineType
* **Scope**: Table

Defines the merge engine for the primary key table. By default, primary key table doesn't have merge engine. The supported merge engines are `first_row`, `versioned`, and `aggregation`. The `first_row` merge engine will keep the first row of the same primary key. The `versioned` merge engine will keep the row with the largest version of the same primary key. The `aggregation` merge engine will aggregate rows with the same primary key using field-level aggregate functions.

---

### `table.merge-engine.versioned.ver-column` {#table-merge-engine-versioned-ver-column}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Table

The column name of the version column for the `versioned` merge engine. If the merge engine is set to `versioned`, the version column must be set.

---

### `table.replication.factor` {#table-replication-factor}

* **Default**: `(none)`
* **Type**: Int
* **Scope**: Table

The replication factor for the log of the new table. When it's not set, Fluss will use the cluster's default replication factor configured by default.replication.factor. It should be a positive number and not larger than the number of tablet servers in the Fluss cluster. A value larger than the number of tablet servers in Fluss cluster will result in an error when the new table is created.

---

## Tablet-server Configurations

### `tablet-server.controlled-shutdown.max-retries` {#tablet-server-controlled-shutdown-max-retries}

* **Default**: `3`
* **Type**: Int
* **Scope**: Server

Maximum number of attempts to transfer leadership before proceeding with an unclean shutdown during a controlled shutdown procedure.

---

### `tablet-server.controlled-shutdown.retry-interval` {#tablet-server-controlled-shutdown-retry-interval}

* **Default**: `PT1S`
* **Type**: Duration
* **Scope**: Server

Time interval between retry attempts when trying to transfer leadership during controlled shutdown.

---

### `tablet-server.host` {#tablet-server-host}

> **Warning**: This configuration is **Deprecated**.

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The external address of the network interface where the TabletServer is exposed. Because different TabletServer need different values for this option, usually it is specified in an additional non-shared TabletServer-specific config file.This option is deprecated. Please use bind.listeners instead, which provides a more flexible configuration for multiple ports

---

### `tablet-server.id` {#tablet-server-id}

* **Default**: `(none)`
* **Type**: Int
* **Scope**: Server

The id for the tablet server.

---

### `tablet-server.port` {#tablet-server-port}

> **Warning**: This configuration is **Deprecated**.

* **Default**: `0`
* **Type**: String
* **Scope**: Server

The external RPC port where the TabletServer is exposed.This option is deprecated. Please use bind.listeners instead, which provides a more flexible configuration for multiple ports

---

### `tablet-server.rack` {#tablet-server-rack}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The rack for the TabletServer. This will be used in rack aware bucket assignment for fault tolerance. Examples: `RACK1`, `cn-hangzhou-server10`

---

## Zookeeper Configurations

### `zookeeper.address` {#zookeeper-address}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The ZooKeeper address to use, when running Fluss with ZooKeeper.

---

### `zookeeper.client.config-path` {#zookeeper-client-config-path}

* **Default**: `(none)`
* **Type**: String
* **Scope**: Server

The file path from which the ZooKeeper client reads its configuration. This allows each ZooKeeper client instance to load its own configuration file, instead of relying on shared JVM-level environment settings. This enables fine-grained control over ZooKeeper client behavior.

---

### `zookeeper.client.connection-timeout` {#zookeeper-client-connection-timeout}

* **Default**: `PT15S`
* **Type**: Duration
* **Scope**: Server

Defines the connection timeout for ZooKeeper in ms.

---

### `zookeeper.client.ensemble-tracker` {#zookeeper-client-ensemble-tracker}

* **Default**: `true`
* **Type**: Boolean
* **Scope**: Server

Defines whether Curator should enable ensemble tracker. This can be useful in certain scenarios in which CuratorFramework is accessing to ZK clusters via load balancer or Virtual IPs. Default Curator EnsembleTracking logic watches CuratorEventType.GET_CONFIG events and changes ZooKeeper connection string. It is not desired behaviour when ZooKeeper is running under the Virtual IPs. Under certain configurations EnsembleTracking can lead to setting of ZooKeeper connection string with unresolvable hostnames.

---

### `zookeeper.client.max-buffer-size` {#zookeeper-client-max-buffer-size}

* **Default**: `104857600`
* **Type**: Int
* **Scope**: Server

The maximum buffer size (in bytes) for ZooKeeper client. This corresponds to the jute.maxbuffer property. Default is 100MB to match the RPC frame length limit.

---

### `zookeeper.client.max-inflight-requests` {#zookeeper-client-max-inflight-requests}

* **Default**: `100`
* **Type**: Int
* **Scope**: Server

The maximum number of unacknowledged requests the client will send to ZooKeeper before blocking.

---

### `zookeeper.client.max-retry-attempts` {#zookeeper-client-max-retry-attempts}

* **Default**: `3`
* **Type**: Int
* **Scope**: Server

Defines the number of connection retries before the client gives up.

---

### `zookeeper.client.retry-wait` {#zookeeper-client-retry-wait}

* **Default**: `PT5S`
* **Type**: Duration
* **Scope**: Server

Defines the pause between consecutive retries in ms.

---

### `zookeeper.client.session-timeout` {#zookeeper-client-session-timeout}

* **Default**: `PT1M`
* **Type**: Duration
* **Scope**: Server

Defines the session timeout for the ZooKeeper session in ms.

---

### `zookeeper.client.tolerate-suspended-connections` {#zookeeper-client-tolerate-suspended-connections}

* **Default**: `false`
* **Type**: Boolean
* **Scope**: Server

Defines whether a suspended ZooKeeper connection will be treated as an error that causes the leader information to be invalidated or not. In case you set this option to true, Fluss will wait until a ZooKeeper connection is marked as lost before it revokes the leadership of components. This has the effect that Fluss is more resilient against temporary connection instabilities at the cost of running more likely into timing issues with ZooKeeper.

---

### `zookeeper.path.root` {#zookeeper-path-root}

* **Default**: `/fluss`
* **Type**: String
* **Scope**: Server

The root path under which Fluss stores its entries in ZooKeeper.

---


